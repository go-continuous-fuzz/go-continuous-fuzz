package main

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"log/slog"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"time"

	cp "github.com/otiai10/copy"
)

const (
	waterMark = "\n> _<small>Generated by [go-continuous-fuzz](https://" +
		"github.com/go-continuous-fuzz/go-continuous-fuzz)</small>_"

	seedCorpusErrMsg = "Failure occurred while testing the seed corpus; " +
		"please check the entries added via f.Add."
)

// cleanupTmpDirs deletes the project, corpus, reports, and binaries directory
// to restart the fuzzing cycle.
func cleanupTmpDirs(logger *slog.Logger, cfg *Config) {
	if err := os.RemoveAll(cfg.Project.SrcDir); err != nil {
		logger.Error("project cleanup failed", "error", err)
	}

	if err := os.RemoveAll(cfg.Project.CorpusDir); err != nil {
		logger.Error("corpus cleanup failed", "error", err)
	}

	if err := os.RemoveAll(cfg.Project.ReportDir); err != nil {
		logger.Error("reports cleanup failed", "error", err)
	}

	if err := os.RemoveAll(cfg.Project.BinaryDir); err != nil {
		logger.Error("binary cleanup failed", "error", err)
	}
}

// cleanupWorkspace deletes the temp directory to reset the workspace state.
// If the user specified --workspace-path, the directory is not removed, since
// keeping it can be useful for debugging crashes in go-continuous-fuzz.
// Any errors encountered during removal are logged, but do not stop execution.
func cleanupWorkspace(logger *slog.Logger, cfg *Config) {
	// If the user specified --workspace-path, do not delete the workspace
	// directory. This allows the user to preserve files for debugging in
	// case go-continuous-fuzz crashes.
	if cfg.Project.WorkSpacePath != "" {
		return
	}

	// Since the config has the path to the project directory and we want to
	// remove its temporary parent directory, we go up one level to its
	// parent directory.
	parentDir := filepath.Dir(cfg.Project.SrcDir)
	if err := os.RemoveAll(parentDir); err != nil {
		logger.Error("workspace cleanup failed", "error", err)
	}
}

// EnsureDirExists creates the specified directory and all necessary parents if
// they do not exist. Returns an error if the directory cannot be created.
func EnsureDirExists(dirPath string) error {
	// Ensure the directory exists (creates parents as needed)
	err := os.MkdirAll(dirPath, 0755)
	if err != nil && !os.IsExist(err) {
		return fmt.Errorf("failed to create directory: %w", err)
	}
	return nil
}

// SanitizeURL parses the given raw URL string and returns a sanitized version
// in which any user credentials (e.g., a GitHub Personal Access Token) are
// replaced with a placeholder ("*****"). This ensures that sensitive
// information is not exposed in logs or output. If the URL cannot be parsed,
// the original URL is returned.
func SanitizeURL(rawURL string) string {
	parsed, err := url.Parse(rawURL)
	if err != nil {
		// If URL parsing fails, return the original URL.
		return rawURL
	}

	// Remove user info (username and password) if present.
	if parsed.User != nil {
		parsed.User = url.User("*****")
	}

	return parsed.String()
}

// calculateFuzzSeconds returns the per-target fuzz duration such that all fuzz
// targets can be processed within the given syncFrequency. It calculates the
// duration by dividing syncFrequency by the maximum number of tasks assigned to
// any worker.
func calculateFuzzSeconds(syncFrequency time.Duration, numWorkers int,
	totalTargets int) time.Duration {

	tasksPerWorker := (totalTargets + numWorkers - 1) / numWorkers
	perTargetSeconds := int(syncFrequency.Seconds()) / tasksPerWorker
	return time.Duration(perTargetSeconds) * time.Second
}

// ComputeSHA256Short computes a SHA-256 hash of the error data(*.go:<line>),
// then returns the first 16 characters of the hash.
func ComputeSHA256Short(errorData string) string {
	hash := sha256.Sum256([]byte(errorData))
	return hex.EncodeToString(hash[:])[:16]
}

// FileExistsInDir checks whether a file with the specified name exists
// directly within the given directory.
func FileExistsInDir(dirPath, fileName string) (bool, error) {
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return false, err
	}

	for _, entry := range entries {
		if !entry.IsDir() && entry.Name() == fileName {
			return true, nil
		}
	}

	return false, nil
}

// extractRepo extracts the repository name from a Git remote URL.
func extractRepo(srcURL string) (string, error) {
	u, err := url.Parse(srcURL)
	if err != nil {
		return "", fmt.Errorf("invalid repository URL: %w", err)
	}

	repo := strings.TrimSuffix(path.Base(u.Path), ".git")
	if repo == "" {
		return "", fmt.Errorf("could not parse repository name from "+
			"%q", srcURL)
	}

	return repo, nil
}

// formatCrashReport constructs a markdown-formatted report containing the error
// logs, the failing test case, and a watermark.
func formatCrashReport(failingLog, failingInputString string) string {
	// Build the "Error logs" section.
	logSection := fmt.Sprintf("## Error logs\n~~~sh\n%s~~~", failingLog)

	// If a crash occurs but we cannot obtain the failing input, it likely
	// stems from a seed corpus entry added via f.Add. In that case, report
	// that the failure happened while testing the seed corpus.
	if failingInputString == "" {
		failingInputString = seedCorpusErrMsg
	}

	// Build the "Failing testcase" section.
	failingTcSection := fmt.Sprintf("## Failing testcase\n~~~sh\n%s\n~~~",
		failingInputString)

	// Combine sections with the watermark at the end.
	return fmt.Sprintf("%s\n%s\n%s\n", logSection, failingTcSection,
		waterMark)
}

// runGoCommand executes a `go` command with the given arguments in the
// specified working directory. It appends any additional environment variables
// provided via extraEnv to the current environment and returns the standard
// output as a string or an error if the command fails.
func runGoCommand(ctx context.Context, workDir string, args []string,
	extraEnv ...string) (string, error) {

	cmd := exec.CommandContext(ctx, "go", args...)
	cmd.Dir = workDir

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr
	cmd.Env = append(os.Environ(), extraEnv...)

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("go command failed: %w\nStderr: %s", err,
			stderr.String())
	}

	return stdout.String(), nil
}

// copyData copies the contents of the src path into the dest path.
// The contents of the source path are recursively copied into the dest.
// If the src path is missing, no error is returned.
// If the dest path does not exist, it will be created.
// If the dest path already exists, the data will be merged, and files with
// the same name will be overwritten.
func copyData(srcPath, destPath string) error {
	// If the source path does not exist, skip copying.
	if _, err := os.Stat(srcPath); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("cannot stat src path %q: %w", srcPath, err)
	}

	// Recursively copy the source path contents into the dest path.
	return cp.Copy(srcPath, destPath)
}
